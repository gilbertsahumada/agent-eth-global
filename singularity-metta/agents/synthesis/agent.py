"""
Synthesis Agent

Purpose: Combines outputs from all agents (MeTTa, LLM, Code Gen) into a
         coherent, well-structured markdown response for the user.
"""

import os
import sys
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional
from uagents import Agent, Context, Protocol

# Add parent directory to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../..'))
from shared_models import (
    SynthesisRequest,
    SynthesizedResponse,
    ErrorResponse
)

# Configuration
AGENT_NAME = "SynthesisAgent"
AGENT_PORT = 8007

# Initialize agent
agent = Agent(
    name=AGENT_NAME,
    port=AGENT_PORT,
    seed="synthesis_agent_seed_phrase_unique_pqr789"  # Change in production
)

# Protocol
protocol = Protocol()

def create_header(query: str) -> str:
    """Create markdown header"""
    return f"# {query}\n\n"


def create_summary_section(llm_response: Optional[Dict], search_results: Dict) -> str:
    """Create summary section"""
    if not llm_response:
        projects = search_results.get("projects_searched", [])
        project_str = ", ".join(projects) if projects else "documentation"
        return f"## Summary\n\nBased on {project_str}, here's what I found:\n\n"

    answer = llm_response.get("answer", "")
    return f"## Summary\n\n{answer}\n\n"


def create_code_examples_section(code_examples: Optional[Dict]) -> str:
    """Create code examples section"""
    if not code_examples:
        return ""

    examples = code_examples.get("examples", [])
    if not examples:
        return ""

    section = "## Code Examples\n\n"

    for idx, example in enumerate(examples, 1):
        code = example.get("code", "")
        language = example.get("language", "text")
        description = example.get("description", "")
        source_project = example.get("source_project", "Unknown")

        section += f"### Example {idx}: {description}\n\n"
        section += f"**Source:** {source_project}\n\n"
        section += f"```{language}\n{code}\n```\n\n"

    return section


def create_implementation_steps_section(metta_reasoning: Optional[Dict]) -> str:
    """Create implementation steps section from MeTTa reasoning"""
    if not metta_reasoning:
        return ""

    execution_order = metta_reasoning.get("execution_order", [])
    if not execution_order:
        return ""

    section = "## Implementation Steps\n\n"

    for idx, step in enumerate(execution_order, 1):
        section += f"{idx}. {step}\n"

    section += "\n"
    return section


def create_dependencies_section(metta_reasoning: Optional[Dict]) -> str:
    """Create dependencies and prerequisites section"""
    if not metta_reasoning:
        return ""

    dependencies = metta_reasoning.get("dependencies", [])
    prerequisites = metta_reasoning.get("prerequisites", [])

    if not dependencies and not prerequisites:
        return ""

    section = "## Dependencies & Prerequisites\n\n"

    if prerequisites:
        section += "**Prerequisites:**\n"
        for prereq in prerequisites[:5]:  # Top 5
            section += f"- {prereq}\n"
        section += "\n"

    if dependencies:
        section += "**Dependencies:**\n"
        for dep in dependencies[:10]:  # Top 10
            section += f"- {dep}\n"
        section += "\n"

    return section


def create_conflicts_section(metta_reasoning: Optional[Dict]) -> str:
    """Create conflicts and warnings section"""
    if not metta_reasoning:
        return ""

    conflicts = metta_reasoning.get("conflicts", [])
    if not conflicts:
        return ""

    section = "## ‚ö†Ô∏è Important Considerations\n\n"

    for conflict in conflicts:
        section += f"- {conflict}\n"

    section += "\n"
    return section


def create_sources_section(search_results: Dict, llm_response: Optional[Dict]) -> str:
    """Create sources section"""
    section = "## Sources\n\n"

    projects = search_results.get("projects_searched", [])
    total_results = search_results.get("total_results", 0)

    if projects:
        section += "**Documentation searched:**\n"
        for project in projects:
            section += f"- {project}\n"
        section += f"\n*Total: {total_results} relevant sections found*\n\n"

    return section


def create_footer(agents_used: List[str], total_time_ms: float) -> str:
    """Create footer with metadata"""
    footer = "---\n\n"
    footer += "*Generated by ASI Alliance Multi-Agent System*\n\n"
    footer += f"**Agents involved:** {', '.join(agents_used)}\n\n"
    footer += f"**Total processing time:** {total_time_ms:.0f}ms\n\n"
    footer += "ü§ñ *Powered by ASI-1 LLM, MeTTa Symbolic Reasoning, and Qdrant Vector Search*\n"

    return footer


def synthesize_response(
    query: str,
    metta_reasoning: Optional[Dict],
    llm_response: Optional[Dict],
    code_examples: Optional[Dict],
    search_results: Dict
) -> tuple[str, Dict[str, str], List[str]]:
    """
    Main synthesis function - combines all agent outputs
    """
    # Track which agents contributed
    agents_used = ["SearchAgent"]  # Always used

    if metta_reasoning:
        agents_used.append("MeTTaReasoningAgent")
    if llm_response:
        agents_used.append("LLMAgent")
    if code_examples and code_examples.get("examples"):
        agents_used.append("CodeGeneratorAgent")

    agents_used.append("SynthesisAgent")

    # Build markdown response
    markdown = ""

    # Header
    markdown += create_header(query)

    # Summary (LLM response or fallback)
    summary = create_summary_section(llm_response, search_results)
    markdown += summary

    # Implementation steps (from MeTTa)
    steps = create_implementation_steps_section(metta_reasoning)
    markdown += steps

    # Code examples
    code_section = create_code_examples_section(code_examples)
    markdown += code_section

    # Dependencies
    deps_section = create_dependencies_section(metta_reasoning)
    markdown += deps_section

    # Conflicts/warnings
    conflicts_section = create_conflicts_section(metta_reasoning)
    markdown += conflicts_section

    # Sources
    sources_section = create_sources_section(search_results, llm_response)
    markdown += sources_section

    # Create structured response
    structure = {
        "answer": llm_response.get("answer", "") if llm_response else summary,
        "code": code_section,
        "reasoning": steps + deps_section + conflicts_section,
        "sources": sources_section
    }

    return markdown, structure, agents_used

@protocol.on_message(SynthesisRequest)
async def handle_synthesis_request(ctx: Context, sender: str, msg: SynthesisRequest):
    """Handle synthesis request"""
    start_time = datetime.now()

    ctx.logger.info(f"üîÑ Synthesis request from {sender}")
    ctx.logger.info(f"  Query: '{msg.query}'")
    ctx.logger.info(f"  Has MeTTa: {msg.metta_reasoning is not None}")
    ctx.logger.info(f"  Has LLM: {msg.llm_response is not None}")
    ctx.logger.info(f"  Has Code: {msg.code_examples is not None}")

    try:
        # Synthesize response
        markdown, structure, agents_used = synthesize_response(
            query=msg.query,
            metta_reasoning=msg.metta_reasoning,
            llm_response=msg.llm_response,
            code_examples=msg.code_examples,
            search_results=msg.search_results
        )

        # Calculate total time
        elapsed_ms = (datetime.now() - start_time).total_seconds() * 1000

        # Add footer with timing info
        markdown += create_footer(agents_used, elapsed_ms)

        ctx.logger.info(f"‚úÖ Synthesized response ({len(markdown)} chars)")
        ctx.logger.info(f"  Agents used: {', '.join(agents_used)}")
        ctx.logger.info(f"  Synthesis time: {elapsed_ms:.2f}ms")

        # Send response
        await ctx.send(
            msg.user_address,
            SynthesizedResponse(
                markdown=markdown,
                structure=structure,
                total_time_ms=elapsed_ms,
                agents_used=agents_used
            )
        )

    except Exception as e:
        ctx.logger.error(f"‚ùå Error synthesizing response: {e}")
        import traceback
        traceback.print_exc()
        await ctx.send(
            msg.user_address,
            ErrorResponse(
                error=str(e),
                agent_name=AGENT_NAME,
                timestamp=datetime.now(timezone.utc).isoformat(),
                details="Synthesis failed"
            )
        )

@agent.on_event("startup")
async def on_startup(ctx: Context):
    ctx.logger.info(f"ü§ñ {AGENT_NAME} started!")
    ctx.logger.info(f"üìç Agent address: {agent.address}")
    ctx.logger.info(f"üåê Listening on port {AGENT_PORT}")
    ctx.logger.info(f"üéØ Ready to synthesize multi-agent responses")


# Register protocol
agent.include(protocol, publish_manifest=True)


if __name__ == "__main__":
    agent.run()
